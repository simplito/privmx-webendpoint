(()=>{"use strict";var e={320:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.encryptWithAES256GCM=async function(e,t,r,n){try{const a=await crypto.subtle.importKey("raw",e,{name:"AES-GCM"},!1,["encrypt"]),s=await crypto.subtle.encrypt({name:"AES-GCM",iv:t,additionalData:n,tagLength:128},a,r);return{success:!0,data:new Uint8Array(s)}}catch(e){return{success:!1,error:"EncryptionFailed"}}},t.decryptWithAES256GCM=async function(e,t,r,n){try{const a=await crypto.subtle.importKey("raw",e,{name:"AES-GCM"},!1,["decrypt"]),s=await crypto.subtle.decrypt({name:"AES-GCM",iv:t,additionalData:n,tagLength:128},a,r);return{success:!0,data:new Uint8Array(s)}}catch(e){return{success:!1,error:"DecryptionFailed"}}},t.isEncryptionSuccess=function(e){return e.success},t.isDecryptionSuccess=function(e){return e.success}},928:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.KeyStore=void 0,t.KeyStore=class{_keys=new Map;_encryptionKeyId=void 0;setKeys(e){this._keys.clear();for(const t of e)this._keys.set(t.keyId,t),0===t.type&&(this._encryptionKeyId=t.keyId)}getKey(e){return this._keys.get(e)}hasKey(e){return this._keys.has(e)}getEncriptionKey(){if(!this._encryptionKeyId)throw console.error("No encryption key set."),console.log("DEBUG-info: ",this._keys),console.trace("Location"),new Error("No encryption key set.");return this._keys.get(this._encryptionKeyId)}}},251:(e,t)=>{Object.defineProperty(t,"__esModule",{value:!0}),t.Utils=void 0;class r{static generateNumericId(){return Math.round(1e15*Math.random())}static getRandomString(e){return[...Array(e)].map((()=>Math.floor(16*Math.random()).toString(16))).join("")}static async encryptSymmetric(e,t,r){let n;n="string"==typeof e?(new TextEncoder).encode(e):e;const a=await crypto.subtle.importKey("raw",Buffer.from(t,"base64"),{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),s=await crypto.subtle.encrypt({name:"AES-GCM",iv:Buffer.from(r,"base64")},a,n);return{ciphertext:Buffer.from(s),iv:r}}static async decryptSymmetricBuffer(e,t,r){const n=await crypto.subtle.importKey("raw",r,{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),a=await crypto.subtle.decrypt({name:"AES-GCM",iv:t},n,e);return Buffer.from(a)}static async decryptSymmetric(e,t,r){const n=await crypto.subtle.importKey("raw",Buffer.from(r,"base64"),{name:"AES-GCM",length:256},!0,["encrypt","decrypt"]),a=await crypto.subtle.decrypt({name:"AES-GCM",iv:Buffer.from(t,"base64")},n,Buffer.from(e,"base64"));return(new TextDecoder).decode(a)}static genKey(){return Buffer.from(crypto.getRandomValues(new Uint8Array(32))).toString("base64")}static genIv(){return Buffer.from(crypto.getRandomValues(new Uint8Array(12))).toString("base64")}static genIvAsBuffer(){return crypto.getRandomValues(new Uint8Array(12))}static base64abc=["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z","a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z","0","1","2","3","4","5","6","7","8","9","+","/"];static base64codes=[255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,62,255,255,255,63,52,53,54,55,56,57,58,59,60,61,255,255,255,0,255,255,255,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,255,255,255,255,255,255,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51];static bytesToBase64(e){let t,n="",a=e.length;for(t=2;t<a;t+=3)n+=r.base64abc[e[t-2]>>2],n+=r.base64abc[(3&e[t-2])<<4|e[t-1]>>4],n+=r.base64abc[(15&e[t-1])<<2|e[t]>>6],n+=r.base64abc[63&e[t]];return t===a+1&&(n+=r.base64abc[e[t-2]>>2],n+=r.base64abc[(3&e[t-2])<<4],n+="=="),t===a&&(n+=r.base64abc[e[t-2]>>2],n+=r.base64abc[(3&e[t-2])<<4|e[t-1]>>4],n+=r.base64abc[(15&e[t-1])<<2],n+="="),n}static isBitOn(e,t){return Boolean(e&1<<t)}static getBits(e,t,r){const n=Math.pow(2,r)-1,a=t/8,s=t%=8;return e[a]>>s&n}static numAsOneByteUint(e){if(e>255)throw new Error("Out of bounds value");const t=new Uint8Array(1);return t[0]=e,t}static oneByteUint8AsNum(e){if(e[0]>255)throw new Error("Out of bounds value");return e[0]}}t.Utils=r}},t={};function r(n){var a=t[n];if(void 0!==a)return a.exports;var s=t[n]={exports:{}};return e[n](s,s.exports,r),s.exports}(()=>{const e=r(251),t=r(320),n=r(928),a=new Map,s=new Map;class i{keyStore;constructor(e){this.keyStore=e}getHeaderSizeByType(e){return"key"===e?10:"delta"===e?3:"undefined"===e?1:0}async encryptFrame(r,n,a){const s="video"===n?this.getHeaderSizeByType(r.type):1,i=new Uint8Array(r.data,0,s),o=new Uint8Array(r.data,s),c=e.Utils.genIvAsBuffer(),y=this.keyStore.getEncriptionKey(),u=await(0,t.encryptWithAES256GCM)(y.key,c,o,i);if(!(0,t.isEncryptionSuccess)(u))throw new Error("Cannot encrypt frame");const p=(new TextEncoder).encode(y.keyId),d=i.byteLength,f=d+u.data.byteLength,l=f+c.byteLength,m=l+1,b=m+p.byteLength,h=new ArrayBuffer(b+1),w=new Uint8Array(h);w.set(i),w.set(u.data,d),w.set(c,f),w.set(e.Utils.numAsOneByteUint(c.byteLength),l),w.set(p,m),JSON.stringify(p),w.set(e.Utils.numAsOneByteUint(p.byteLength),b),r.data=h,a.enqueue(r)}async decryptFrame(r,n,a){const s="video"===n?this.getHeaderSizeByType(r.type):1,i=r.data,o=new Uint8Array(i,0,s),c=new Uint8Array(i,i.byteLength-1,1),u=e.Utils.oneByteUint8AsNum(c),p=new Uint8Array(i,i.byteLength-2-u,1),d=e.Utils.oneByteUint8AsNum(p),f=s+u+d+2,l=i.byteLength-f,m=i.slice(s,s+l),b=s+l+d+1,h=i.slice(b,b+u),w=(new TextDecoder).decode(h);try{if(!this.keyStore.hasKey(w))return void a.enqueue(r);const e=this.keyStore.getKey(w),n=new Uint8Array(i.slice(s+l,s+l+d)),c=await(0,t.decryptWithAES256GCM)(e.key,n,m,o);if(!(0,t.isDecryptionSuccess)(c))return void a.enqueue(r);const y=c.data,u=new ArrayBuffer(o.byteLength+y.byteLength),p=new Uint8Array(u);p.set(o),p.set(new Uint8Array(y),o.byteLength),r.data=u,a.enqueue(r)}catch(e){y(e),a.enqueue(r)}}}self.keyStore=new n.KeyStore;const o=()=>self.keyStore;function c(e,t,r,n,s,o){let c;if(JSON.stringify({operation:t,context:e}),"encode"==t)c=function(e,t){const r=new i(e);return new TransformStream({start(){},async transform(e,n){r.encryptFrame(e,t,n)},flush(){}})}(e.keyStore,r),n.pipeThrough(c).pipeTo(s);else if("decode"==t){c=function(e,t){const r=new i(e);return new TransformStream({start(){},flush(){},async transform(e,n){r.decryptFrame(e,t,n)}})}(e.keyStore,r);const t=n.pipeThrough(c).pipeTo(s).catch((e=>{String(e).includes("Destination stream closed")||console.error("pipeline error",e)}));a.set(o,{pipeline:t})}else if("stop"===t){const e=a.get(o);if(e){try{e.pipeline.abort&&e.pipeline.abort()}catch{}a.delete(o)}}else y(`Invalid operation: ${t}`)}function y(e){postMessage({type:"error",data:e})}self.onmessage=async e=>{const{operation:t,kind:r}=e.data;if("initialize"===t);else{if("init-pipeline"===t)return console.log("in worker: 1"),s.set(e.data.id,{ready:!1}),void self.postMessage({operation:"init-pipeline",id:e.data.id});if("encode"===t||"decode"===t){const n={keyStore:o()},{readableStream:a,writableStream:s,id:i}=e.data;c(n,t,r,a,s,i)}else if("setKeys"===t){const t=e.data;o().setKeys(t.keys)}}},self.RTCTransformEvent&&(y("init RTCTransfrom"),self.onrtctransform=e=>{const t=e.transformer,{operation:r,kind:n}=t.options;JSON.stringify(e),c({keyStore:o()},r,n,t.readable,t.writable,0)})})()})();